<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cosmic Maze Exercise - Fine Motor Skills Rehabilitation | Fine Point Rehab</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Interactive cosmic maze exercise for fine motor skills rehabilitation, stroke recovery, and upper limb therapy. Digital therapeutic exercise for neurological rehabilitation, hand-eye coordination, and dexterity improvement. Suitable for occupational therapy, physiotherapy, and home-based rehabilitation programs. Helps patients with stroke, brain injury, cerebral palsy, and neurological conditions improve motor control, precision movements, and functional recovery.">
    
    <meta name="keywords" content="fine motor skills exercises, upper limb rehabilitation, stroke recovery exercises, neuro rehabilitation games, occupational therapy activities, physiotherapy exercises, hand therapy exercises, motor control training, digital therapeutics, home rehabilitation exercises, hand-eye coordination, dexterity training, brain injury rehabilitation, neurological therapy, therapeutic games, motor function recovery, arm rehabilitation, finger exercises, precision movement therapy, adaptive therapy">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Cosmic Maze Exercise - Fine Motor Skills & Upper Limb Rehabilitation | Fine Point Rehab">
    <meta property="og:description" content="Interactive digital therapeutic exercise for fine motor skills rehabilitation, stroke recovery, and neurological therapy. Improve hand-eye coordination and motor control through engaging maze navigation.">
    <meta property="og:type" content="website">
    <meta property="og:image" content="/api/placeholder/1200/630">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Cosmic Maze Exercise - Fine Motor Skills Rehabilitation | Fine Point Rehab">
    <meta name="twitter:description" content="Digital therapeutic maze game for upper limb rehabilitation, fine motor skills training, and neurological recovery.">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://finepointrehab.com/cosmic-maze-exercise">
    
    <!-- Schema.org Markup -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "MedicalWebPage",
        "name": "Cosmic Maze Exercise - Fine Motor Skills Rehabilitation | Fine Point Rehab",
        "description": "Interactive digital therapeutic exercise for fine motor skills rehabilitation, stroke recovery, and upper limb therapy",
        "medicalAudience": {
            "@type": "MedicalAudience",
            "audienceType": "Patient",
            "healthCondition": [
                "Stroke",
                "Brain Injury",
                "Cerebral Palsy",
                "Motor Impairment",
                "Upper Limb Dysfunction"
            ]
        },
        "specialty": [
            "Occupational Therapy",
            "Physical Therapy",
            "Neurorehabilitation"
        ],
        "benefits": [
            "Improves fine motor control",
            "Enhances hand-eye coordination",
            "Develops precision movements",
            "Supports neuroplasticity",
            "Facilitates motor recovery"
        ]
    }
    </script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            background: #121d33;
            color: white;
            min-height: 100vh;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #maze-container {
            position: relative;
            background-color: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(111, 211, 245, 0.3);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(111, 211, 245, 0.2);
            touch-action: none;
            outline: none;
        }
        
        .maze-wall {
            position: absolute;
            background: linear-gradient(135deg, rgba(7, 25, 59, 0.9), rgba(11, 42, 88, 0.9));
            border: 1px solid rgba(111, 211, 245, 0.3);
            box-shadow: 0 0 8px rgba(111, 211, 245, 0.2);
        }
        
        /* Path lines styling - dotted lines in center of paths */
        .path-line {
            position: absolute;
            z-index: 2;
        }
        
        .path-line.horizontal {
            height: 2px;
            background-image: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 4px,
                rgba(111, 211, 245, 0.5) 4px,
                rgba(111, 211, 245, 0.5) 8px
            );
        }
        
        .path-line.vertical {
            width: 2px;
            background-image: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 4px,
                rgba(111, 211, 245, 0.5) 4px,
                rgba(111, 211, 245, 0.5) 8px
            );
        }
        
        /* Path intersection nodes */
        .path-node {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: rgba(111, 211, 245, 0.7);
            border-radius: 50%;
            z-index: 3;
            transform: translate(-50%, -50%);
        }
        
        #player {
            position: absolute;
            width: 30px;
            height: 30px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23ffffff"><path d="M12,1L2,8.5V20.5H22V8.5L12,1M12,3.5L19,9V10.5H5V9L12,3.5M5,20.5V12H19V20.5H5M8.5,12.5A2.5,2.5 0 0,0 6,15A2.5,2.5 0 0,0 8.5,17.5A2.5,2.5 0 0,0 11,15A2.5,2.5 0 0,0 8.5,12.5M15.5,12.5A2.5,2.5 0 0,0 13,15A2.5,2.5 0 0,0 15.5,17.5A2.5,2.5 0 0,0 18,15A2.5,2.5 0 0,0 15.5,12.5M12,12V20H7V15H17V20H12V12Z"/></svg>');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            background-color: rgba(111, 211, 245, 0.1);
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
            box-shadow: 0 0 15px rgba(111, 211, 245, 0.6);
            touch-action: none;
            animation: pulse 1.5s infinite alternate;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 15px rgba(111, 211, 245, 0.6); }
            100% { box-shadow: 0 0 25px rgba(111, 211, 245, 0.8); }
        }
        
        #goal {
            position: absolute;
            width: 40px;
            height: 40px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%234CAF50"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4M12,6.5A5.5,5.5 0 0,0 6.5,12A5.5,5.5 0 0,0 12,17.5A5.5,5.5 0 0,0 17.5,12A5.5,5.5 0 0,0 12,6.5M12,9A3,3 0 0,1 15,12A3,3 0 0,1 12,15A3,3 0 0,1 9,12A3,3 0 0,1 12,9Z"/></svg>');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            border-radius: 50%;
            z-index: 5;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.7);
            animation: earth-pulse 2s infinite alternate;
            transform: translate(-50%, -50%);
        }
        
        @keyframes earth-pulse {
            0% { box-shadow: 0 0 20px rgba(76, 175, 80, 0.7); }
            100% { box-shadow: 0 0 30px rgba(76, 175, 80, 0.9); }
        }
        
        .path-trace {
            position: absolute;
            background-color: rgba(111, 211, 245, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: 2;
        }
        
        #timer-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 8px;
            background-color: rgba(111, 211, 245, 0.9);
            width: 100%;
            z-index: 20;
            transition: width 0.1s linear;
        }
        
        #settings-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(8, 15, 35, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.1);
            z-index: 100;
            width: 80%;
            max-width: 400px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #settings-panel h2 {
            text-align: center;
            color: white;
            margin-top: 0;
            margin-bottom: 25px;
            font-size: 24px;
            letter-spacing: 0.5px;
        }
        
        #settings-toggle {
            position: fixed;
            bottom: 15px;
            right: 15px;
            background-color: rgba(111, 211, 245, 0.8);
            color: #121d33;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            z-index: 90;
            transition: all 0.2s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #settings-toggle:hover {
            background-color: rgba(111, 211, 245, 1);
            transform: translateY(-2px);
        }
        
        #home-button {
            position: fixed;
            bottom: 15px;
            right: 15px;
            background-color: rgba(111, 211, 245, 0.8);
            color: #121d33;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            z-index: 90;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }
        
        #home-button:hover {
            background-color: rgba(111, 211, 245, 1);
            transform: translateY(-2px);
        }
        
        .settings-group {
            margin-bottom: 20px;
        }
        
        .settings-label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: white;
            font-size: 16px;
        }
        
        select, input {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 16px;
            background-color: rgba(0, 10, 30, 0.8);
            color: white;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: rgba(111, 211, 245, 0.8);
            box-shadow: 0 0 0 2px rgba(111, 211, 245, 0.3);
        }
        
        button {
            background-color: rgba(111, 211, 245, 0.9);
            color: #121d33;
            border: none;
            border-radius: 10px;
            padding: 12px 15px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 15px;
            width: 100%;
            transition: all 0.2s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }
        
        button:hover {
            background-color: rgba(111, 211, 245, 1);
            transform: translateY(-2px);
        }
        
        #stats-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(8, 15, 35, 0.8);
            padding: 15px;
            display: flex;
            justify-content: space-around;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
        }
        
        .stat-box {
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: rgba(111, 211, 245, 1);
        }
        
        .stat-label {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        }
        
        #completion-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(8, 15, 35, 0.95);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.1);
            text-align: center;
            max-width: 80%;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #completion-message h2 {
            color: white;
            margin-top: 0;
        }
        
        #completion-scores {
            margin: 20px 0;
            font-size: 18px;
        }
        
        .score-highlight {
            color: rgba(111, 211, 245, 1);
            font-weight: bold;
        }
        
        #stars-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            overflow: hidden;
            pointer-events: none;
        }
        
        .star {
            position: absolute;
            background-color: white;
            width: 2px;
            height: 2px;
            border-radius: 50%;
            opacity: 0.4;
        }
        
        .instructions {
            text-align: center;
            color: rgba(255, 255, 255, 0.9);
            margin: 0;
            font-size: 16px;
            padding: 15px;
            background-color: rgba(8, 15, 35, 0.7);
            border-radius: 8px;
            margin-bottom: 15px;
            max-width: 600px;
        }
        
        #error-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(220, 53, 69, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            z-index: 200;
            display: none;
            animation: slideDown 0.3s ease;
        }
        
        @keyframes slideDown {
            from { transform: translate(-50%, -100%); }
            to { transform: translate(-50%, 0); }
        }
        
        .hidden {
            display: none !important;
        }
        
        @media (max-width: 768px) {
            .stat-value {
                font-size: 20px;
            }
            
            .stat-label {
                font-size: 12px;
            }
            
            .instructions {
                font-size: 14px;
                padding: 10px;
            }
            
            #settings-panel {
                width: 90%;
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="stars-container"></div>
        <div id="timer-bar" class="hidden"></div>
        <div id="error-message"></div>
        <p class="instructions">Guide the spaceship through the cosmic maze to reach Earth. This therapeutic exercise improves fine motor skills, hand-eye coordination, and precision movements. Drag the spaceship or use arrow keys to navigate along the dotted lines. Perfect for stroke rehabilitation, neurological recovery, and upper limb therapy.</p>
        
        <div id="maze-container" tabindex="0"></div>
        
        <button id="home-button"
                aria-label="Go to Home"
                onclick="window.location.href='index.html'"
                title="Return to Home">
            Home
        </button>
        
        <div id="settings-panel">
            <h2>Therapeutic Exercise Settings</h2>
            <div class="settings-group">
                <label class="settings-label">Difficulty Level (Motor Control Challenge):</label>
                <select id="difficulty" aria-label="Select difficulty level">
                    <option value="easy" selected>Easy (Wide Paths) - Beginning Motor Recovery</option>
                    <option value="medium">Medium - Intermediate Motor Control</option>
                    <option value="hard">Hard (Narrow Paths) - Advanced Precision Training</option>
                </select>
            </div>
            
            <div class="settings-group">
                <label class="settings-label">Therapy Session Duration (minutes):</label>
                <input type="number" id="session-duration" min="1" max="10" value="5" aria-label="Set session duration">
            </div>
            
            <div class="settings-group">
                <label class="settings-label">Visual Feedback (Path Trace):</label>
                <select id="show-trace" aria-label="Enable or disable path trace">
                    <option value="yes" selected>Yes - Shows Movement Pattern</option>
                    <option value="no">No - Clean Navigation</option>
                </select>
            </div>
            
            <button id="start-session">Start Rehabilitation Session</button>
        </div>
        
        <div id="stats-panel" class="hidden">
            <div class="stat-box">
                <div id="mazes-completed" class="stat-value">0</div>
                <div class="stat-label">Completed</div>
            </div>
            <div class="stat-box">
                <div id="current-maze" class="stat-value">1</div>
                <div class="stat-label">Current Maze</div>
            </div>
            <div class="stat-box">
                <div id="time-left" class="stat-value">5:00</div>
                <div class="stat-label">Time Left</div>
            </div>
            <div class="stat-box">
                <div id="avg-time" class="stat-value">0.0s</div>
                <div class="stat-label">Avg. Completion</div>
            </div>
        </div>
        
        <div id="completion-message" class="hidden">
            <h2>Therapy Session Complete!</h2>
            <div id="completion-scores">
                <p>Mazes Completed: <span id="final-completed" class="score-highlight">0</span></p>
                <p>Average Completion Time: <span id="final-avg-time" class="score-highlight">0.0s</span></p>
                <p>Motor Performance Score: <span id="final-score" class="score-highlight">0</span></p>
            </div>
            <button id="restart-button">Start New Therapy Session</button>
        </div>
    </div>
    
    <script>
        // Game elements
        const gameContainer = document.getElementById('game-container');
        const mazeContainer = document.getElementById('maze-container');
        const timerBar = document.getElementById('timer-bar');
        const settingsPanel = document.getElementById('settings-panel');
        const statsPanel = document.getElementById('stats-panel');
        const completionMessage = document.getElementById('completion-message');
        const starsContainer = document.getElementById('stars-container');
        const instructions = document.querySelector('.instructions');
        const errorMessage = document.getElementById('error-message');
        
        // Create stars for background effect
        const starsCount = 150;
        
        for (let i = 0; i < starsCount; i++) {
            const star = document.createElement('div');
            star.classList.add('star');
            
            // Random position
            star.style.left = `${Math.random() * 100}%`;
            star.style.top = `${Math.random() * 100}%`;
            
            // Random size
            const size = Math.random() * 2 + 0.5;
            star.style.width = `${size}px`;
            star.style.height = `${size}px`;
            
            // Random opacity for subtle effect
            star.style.opacity = Math.random() * 0.4 + 0.1;
            
            starsContainer.appendChild(star);
        }
        
        // Settings elements
        const difficultySelect = document.getElementById('difficulty');
        const sessionDurationInput = document.getElementById('session-duration');
        const showTraceSelect = document.getElementById('show-trace');
        const startSessionButton = document.getElementById('start-session');
        const restartButton = document.getElementById('restart-button');
        
        // Stats elements
        const mazesCompletedElement = document.getElementById('mazes-completed');
        const currentMazeElement = document.getElementById('current-maze');
        const timeLeftElement = document.getElementById('time-left');
        const avgTimeElement = document.getElementById('avg-time');
        
        // Completion elements
        const finalCompletedElement = document.getElementById('final-completed');
        const finalAvgTimeElement = document.getElementById('final-avg-time');
        const finalScoreElement = document.getElementById('final-score');
        
        // Game variables
        let isSessionActive = false;
        let sessionDuration = 5 * 60 * 1000; // 5 minutes in milliseconds
        let timeRemaining = 0;
        let timerInterval = null;
        let mazesCompleted = 0;
        let currentMaze = 1;
        let totalCompletionTime = 0;
        let mazeStartTime = 0;
        let showTrace = true;
        let player = null;
        let goal = null;
        let isDragging = false;
        let maze = [];
        let mazeWidth = 600;
        let mazeHeight = 400;
        let cellSize = 50;
        let wallThickness = 10;
        let currentDifficulty = 'easy';
        let pathTraces = [];
        let pathNodes = []; // Store path node positions for navigation
        let playerNodeIndex = 0; // Current player position on path
        
        // Event handlers storage - ADD THIS TO TRACK EVENT LISTENERS
        let eventHandlers = {
            keydown: null,
            mousedown: null,
            touchstart: null,
            mousemove: null,
            touchmove: null,
            mouseup: null,
            touchend: null
        };
        
        // Difficulty settings
        const difficultySizes = {
            'easy': { cellSize: 60, wallThickness: 12 },
            'medium': { cellSize: 45, wallThickness: 10 },
            'hard': { cellSize: 30, wallThickness: 8 }
        };
        
        // Initialize the game once the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            adjustMazeSize();
            showSettings();
        });
        
        // Start new session
        startSessionButton.addEventListener('click', startSession);
        restartButton.addEventListener('click', () => {
            completionMessage.classList.add('hidden');
            settingsPanel.classList.remove('hidden');
        });
        
        // Adjust maze size based on screen
        function adjustMazeSize() {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Maximum maze size based on screen (with margins)
            mazeWidth = Math.min(600, windowWidth * 0.9);
            mazeHeight = Math.min(400, windowHeight * 0.6);
            
            // Update maze container size
            mazeContainer.style.width = `${mazeWidth}px`;
            mazeContainer.style.height = `${mazeHeight}px`;
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            adjustMazeSize();
            if (isSessionActive) {
                // Regenerate maze with new size
                generateMaze();
            }
        });
        
        // Clear intervals on page unload
        window.addEventListener('beforeunload', () => {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            // Clean up any remaining event listeners
            removeAllEventListeners();
        });
        
        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
            setTimeout(() => {
                errorMessage.style.display = 'none';
            }, 3000);
        }
        
        // Update stats display
        function updateStats() {
            mazesCompletedElement.textContent = mazesCompleted;
            currentMazeElement.textContent = currentMaze;
            
            // Calculate and display average completion time
            const avgTime = mazesCompleted > 0 ? (totalCompletionTime / mazesCompleted / 1000).toFixed(1) : '0.0';
            avgTimeElement.textContent = `${avgTime}s`;
        }
        
        // Update timer display
        function updateTimer() {
            const minutes = Math.floor(timeRemaining / 60000);
            const seconds = Math.floor((timeRemaining % 60000) / 1000);
            timeLeftElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // Clear maze elements AND event listeners
        function clearMaze() {
            console.log("Clearing maze");
            
            // First, remove all event listeners
            removeAllEventListeners();
            
            // Remove all child elements from maze container
            while (mazeContainer.firstChild) {
                mazeContainer.removeChild(mazeContainer.firstChild);
            }
            
            // Clear path traces array
            pathTraces = [];
            
            // Ensure pathNodes is reset to an empty array
            pathNodes = [];
            
            console.log("Maze cleared");
        }
        
        // Remove all event listeners
        function removeAllEventListeners() {
            // Remove keyboard event listener
            if (eventHandlers.keydown) {
                mazeContainer.removeEventListener('keydown', eventHandlers.keydown);
                eventHandlers.keydown = null;
            }
            
            // Remove mouse/touch event listeners
            if (player) {
                if (eventHandlers.mousedown) {
                    player.removeEventListener('mousedown', eventHandlers.mousedown);
                    eventHandlers.mousedown = null;
                }
                
                if (eventHandlers.touchstart) {
                    player.removeEventListener('touchstart', eventHandlers.touchstart);
                    eventHandlers.touchstart = null;
                }
            }
            
            // Remove document level event listeners
            if (eventHandlers.mousemove) {
                document.removeEventListener('mousemove', eventHandlers.mousemove);
                eventHandlers.mousemove = null;
            }
            
            if (eventHandlers.touchmove) {
                document.removeEventListener('touchmove', eventHandlers.touchmove);
                eventHandlers.touchmove = null;
            }
            
            if (eventHandlers.mouseup) {
                document.removeEventListener('mouseup', eventHandlers.mouseup);
                eventHandlers.mouseup = null;
            }
            
            if (eventHandlers.touchend) {
                document.removeEventListener('touchend', eventHandlers.touchend);
                eventHandlers.touchend = null;
            }
        }
        
        // Show settings panel
        function showSettings() {
            settingsPanel.classList.remove('hidden');
            statsPanel.classList.add('hidden');
            timerBar.classList.add('hidden');
        }
        
        function startSession() {
            try {
                // Get settings
                currentDifficulty = difficultySelect.value;
                sessionDuration = parseInt(sessionDurationInput.value) * 60 * 1000; // Convert minutes to ms
                showTrace = showTraceSelect.value === 'yes';
                
                // Initialize game state
                mazesCompleted = 0;
                currentMaze = 1;
                totalCompletionTime = 0;
                timeRemaining = sessionDuration;
                
                console.log("Session initialized, settings applied");
                
                // Update UI
                updateStats();
                updateTimer();
                
                // Clear any existing maze and event listeners
                clearMaze();
                
                // Hide settings, show stats
                settingsPanel.classList.add('hidden');
                instructions.classList.remove('hidden');
                statsPanel.classList.remove('hidden');
                timerBar.classList.remove('hidden');
                
                console.log("UI updated, about to start timer");
                
                // Start timer
                isSessionActive = true;
                
                timerInterval = setInterval(() => {
                    timeRemaining -= 100; // Update every 100ms
                    
                    // Update timer bar
                    const progress = timeRemaining / sessionDuration;
                    timerBar.style.width = `${progress * 100}%`;
                    
                    // Update time display
                    updateTimer();
                    
                    // Check if session is over
                    if (timeRemaining <= 0) {
                        endSession();
                    }
                }, 100);
                
                console.log("Timer started, about to generate maze");
                
                // Generate first maze
                generateMaze();
                mazeStartTime = Date.now();
                
                // Focus on maze for keyboard controls
                mazeContainer.focus();
                
                console.log("Session successfully started");
                
            } catch (error) {
                console.error('Failed to start session:', error);
                showError('Failed to start session: ' + error.message);
            }
        }
        
        // Complete current maze and generate a new one
        function completeCurrentMaze() {
            // Calculate completion time
            const completionTime = Date.now() - mazeStartTime;
            totalCompletionTime += completionTime;
            
            // Update statistics
            mazesCompleted++;
            currentMaze++;
            updateStats();
            
            // Generate a new maze
            generateMaze();
            mazeStartTime = Date.now();
        }
        
        // End the current session and show results
        function endSession() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Clean up
            isSessionActive = false;
            clearMaze();
            
            // Hide timer and stats panels
            timerBar.classList.add('hidden');
            statsPanel.classList.add('hidden');
            
            // Calculate final score
            const avgTime = mazesCompleted > 0 ? (totalCompletionTime / mazesCompleted / 1000).toFixed(1) : '0.0';
            const performanceScore = Math.round((mazesCompleted * 100) / (avgTime > 0 ? avgTime : 1));
            
            // Show completion message with results
            finalCompletedElement.textContent = mazesCompleted;
            finalAvgTimeElement.textContent = `${avgTime}s`;
            finalScoreElement.textContent = performanceScore;
            completionMessage.classList.remove('hidden');
        }
        
        // Get unvisited neighboring cells for maze generation
        function getUnvisitedNeighbors(x, y) {
            const neighbors = [];
            const rows = maze.length;
            const cols = maze[0].length;
            
            // Check each direction (up, right, down, left)
            const directions = [
                { dx: 0, dy: -1 }, // up
                { dx: 1, dy: 0 },  // right
                { dx: 0, dy: 1 },  // down
                { dx: -1, dy: 0 }  // left
            ];
            
            // Shuffle directions to create a more random maze
            shuffleArray(directions);
            
            for (const dir of directions) {
                const newX = x + dir.dx;
                const newY = y + dir.dy;
                
                // Check if the new coordinates are within the grid
                if (newX >= 0 && newX < cols && newY >= 0 && newY < rows) {
                    // Check if the neighbor has not been visited
                    if (!maze[newY][newX].visited) {
                        neighbors.push({ x: newX, y: newY });
                    }
                }
            }
            
            return neighbors;
        }
        
        // Helper function to shuffle an array (Fisher-Yates algorithm)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        // Create maze walls based on the generated maze data
        function createMazeWalls(cols, rows) {
            // Create outer walls
            const topWall = document.createElement('div');
            topWall.className = 'maze-wall';
            topWall.style.top = '0';
            topWall.style.left = '0';
            topWall.style.width = `${cols * cellSize}px`;
            topWall.style.height = `${wallThickness}px`;
            mazeContainer.appendChild(topWall);
            
            const leftWall = document.createElement('div');
            leftWall.className = 'maze-wall';
            leftWall.style.top = '0';
            leftWall.style.left = '0';
            leftWall.style.width = `${wallThickness}px`;
            leftWall.style.height = `${rows * cellSize}px`;
            mazeContainer.appendChild(leftWall);
            
            const rightWall = document.createElement('div');
            rightWall.className = 'maze-wall';
            rightWall.style.top = '0';
            rightWall.style.left = `${cols * cellSize - wallThickness}px`;
            rightWall.style.width = `${wallThickness}px`;
            rightWall.style.height = `${rows * cellSize}px`;
            mazeContainer.appendChild(rightWall);
            
            const bottomWall = document.createElement('div');
            bottomWall.className = 'maze-wall';
            bottomWall.style.top = `${rows * cellSize - wallThickness}px`;
            bottomWall.style.left = '0';
            bottomWall.style.width = `${cols * cellSize}px`;
            bottomWall.style.height = `${wallThickness}px`;
            mazeContainer.appendChild(bottomWall);
            
            // Create inner walls based on the maze data
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const cell = maze[i][j];
                    
                    // Add right wall if needed
                    if (cell.walls.right && j < cols - 1) {
                        const rightWall = document.createElement('div');
                        rightWall.className = 'maze-wall';
                        rightWall.style.top = `${i * cellSize}px`;
                        rightWall.style.left = `${(j + 1) * cellSize - wallThickness / 2}px`;
                        rightWall.style.width = `${wallThickness}px`;
                        rightWall.style.height = `${cellSize}px`;
                        mazeContainer.appendChild(rightWall);
                    }
                    
                    // Add bottom wall if needed
                    if (cell.walls.bottom && i < rows - 1) {
                        const bottomWall = document.createElement('div');
                        bottomWall.className = 'maze-wall';
                        bottomWall.style.top = `${(i + 1) * cellSize - wallThickness / 2}px`;
                        bottomWall.style.left = `${j * cellSize}px`;
                        bottomWall.style.width = `${cellSize}px`;
                        bottomWall.style.height = `${wallThickness}px`;
                        mazeContainer.appendChild(bottomWall);
                    }
                }
            }
        }
        
        // Create path lines and nodes for navigation
        function createPathLines(cols, rows) {
            try {
                console.log("Creating path lines and nodes");
                
                // Create path nodes at the center of each cell
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const centerX = j * cellSize + cellSize / 2;
                        const centerY = i * cellSize + cellSize / 2;
                        
                        // Create a node at this position
                        const node = {
                            x: centerX,
                            y: centerY,
                            gridX: j,
                            gridY: i,
                            connections: []
                        };
                        
                        // Add to pathNodes array
                        pathNodes.push(node);
                        
                        // Create visible node element
                        const nodeElement = document.createElement('div');
                        nodeElement.className = 'path-node';
                        nodeElement.style.left = `${centerX}px`;
                        nodeElement.style.top = `${centerY}px`;
                        mazeContainer.appendChild(nodeElement);
                    }
                }
                
                // Connect nodes based on maze structure
                connectPathNodes(cols, rows);
                
                // Create path lines between connected nodes
                for (let i = 0; i < pathNodes.length; i++) {
                    const node = pathNodes[i];
                    
                    for (const connectedIndex of node.connections) {
                        const connectedNode = pathNodes[connectedIndex];
                        
                        // Only create path line if this is the "forward" connection
                        // (to avoid duplicate lines)
                        if (i < connectedIndex) {
                            // Create a path line between these nodes
                            const line = document.createElement('div');
                            line.className = 'path-line';
                            
                            if (node.gridX === connectedNode.gridX) {
                                // Vertical path line
                                line.classList.add('vertical');
                                const top = Math.min(node.y, connectedNode.y);
                                const height = Math.abs(node.y - connectedNode.y);
                                
                                line.style.left = `${node.x}px`;
                                line.style.top = `${top}px`;
                                line.style.height = `${height}px`;
                            } else {
                                // Horizontal path line
                                line.classList.add('horizontal');
                                const left = Math.min(node.x, connectedNode.x);
                                const width = Math.abs(node.x - connectedNode.x);
                                
                                line.style.left = `${left}px`;
                                line.style.top = `${node.y}px`;
                                line.style.width = `${width}px`;
                            }
                            
                            mazeContainer.appendChild(line);
                        }
                    }
                }
                
                console.log(`Created ${pathNodes.length} path nodes`);
                
            } catch (error) {
                console.error("Error creating path lines:", error);
                showError("Path creation failed: " + error.message);
            }
        }
        
        // Connect path nodes based on maze structure
        function connectPathNodes(cols, rows) {
            try {
                console.log("Connecting path nodes...");
                
                // Iterate through each cell in the grid
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        // Find the index of the node at this grid position
                        const currentNodeIndex = pathNodes.findIndex(node => node.gridX === x && node.gridY === y);
                        
                        if (currentNodeIndex === -1) continue; // No node at this position
                        
                        const currentNode = pathNodes[currentNodeIndex];
                        
                        // Check each direction for potential connections
                        if (x > 0 && !maze[y][x].walls.left) {
                            // Connect to the node to the left
                            const leftNodeIndex = pathNodes.findIndex(node => node.gridX === x - 1 && node.gridY === y);
                            if (leftNodeIndex !== -1 && !currentNode.connections.includes(leftNodeIndex)) {
                                currentNode.connections.push(leftNodeIndex);
                                pathNodes[leftNodeIndex].connections.push(currentNodeIndex);
                                console.log(`Connected node (${x},${y}) to (${x-1},${y})`);
                            }
                        }
                        
                        if (x < cols - 1 && !maze[y][x].walls.right) {
                            // Connect to the node to the right
                            const rightNodeIndex = pathNodes.findIndex(node => node.gridX === x + 1 && node.gridY === y);
                            if (rightNodeIndex !== -1 && !currentNode.connections.includes(rightNodeIndex)) {
                                currentNode.connections.push(rightNodeIndex);
                                pathNodes[rightNodeIndex].connections.push(currentNodeIndex);
                                console.log(`Connected node (${x},${y}) to (${x+1},${y})`);
                            }
                        }
                        
                        if (y > 0 && !maze[y][x].walls.top) {
                            // Connect to the node above
                            const topNodeIndex = pathNodes.findIndex(node => node.gridX === x && node.gridY === y - 1);
                            if (topNodeIndex !== -1 && !currentNode.connections.includes(topNodeIndex)) {
                                currentNode.connections.push(topNodeIndex);
                                pathNodes[topNodeIndex].connections.push(currentNodeIndex);
                                console.log(`Connected node (${x},${y}) to (${x},${y-1})`);
                            }
                        }
                        
                        if (y < rows - 1 && !maze[y][x].walls.bottom) {
                            // Connect to the node below
                            const bottomNodeIndex = pathNodes.findIndex(node => node.gridX === x && node.gridY === y + 1);
                            if (bottomNodeIndex !== -1 && !currentNode.connections.includes(bottomNodeIndex)) {
                                currentNode.connections.push(bottomNodeIndex);
                                pathNodes[bottomNodeIndex].connections.push(currentNodeIndex);
                                console.log(`Connected node (${x},${y}) to (${x},${y+1})`);
                            }
                        }
                    }
                }
                
                console.log("Path nodes connected");
            } catch (error) {
                console.error("Error connecting path nodes:", error);
                throw new Error("Node connection failed: " + error.message);
            }
        }
        
        // Generate a new maze
        function generateMaze() {
            try {
                console.log("Beginning maze generation");
                
                // Check if the required variables are defined
                if (!difficultySizes || !currentDifficulty || !difficultySizes[currentDifficulty]) {
                    throw new Error(`Invalid difficulty settings: ${currentDifficulty}`);
                }
                
                // Update cell size and wall thickness based on difficulty
                cellSize = difficultySizes[currentDifficulty].cellSize;
                wallThickness = difficultySizes[currentDifficulty].wallThickness;
                
                console.log(`Difficulty: ${currentDifficulty}, cellSize: ${cellSize}, wallThickness: ${wallThickness}`);
                
                // Calculate grid size
                if (typeof mazeWidth !== 'number' || typeof mazeHeight !== 'number') {
                    throw new Error(`Invalid maze dimensions: ${mazeWidth}x${mazeHeight}`);
                }
                
                const cols = Math.floor(mazeWidth / cellSize);
                const rows = Math.floor(mazeHeight / cellSize);
                
                if (cols <= 0 || rows <= 0) {
                    throw new Error(`Invalid grid dimensions: ${cols}x${rows}`);
                }
                
                console.log(`Grid size: ${cols}x${rows}`);
                
                // Clear maze container and reset arrays
                clearMaze();
                
                // Explicitly initialize arrays
                maze = [];
                pathNodes = [];
                
                // Initialize maze grid with cells
                for (let i = 0; i < rows; i++) {
                    const row = [];
                    for (let j = 0; j < cols; j++) {
                        row.push({
                            x: j,
                            y: i,
                            visited: false,
                            walls: { top: true, right: true, bottom: true, left: true }
                        });
                    }
                    maze.push(row);
                }
                
                if (maze.length === 0 || maze[0].length === 0) {
                    throw new Error("Failed to create maze grid");
                }
                
                console.log("Maze grid initialized, generating paths");
                
                // Generate maze using depth-first search algorithm
                const stack = [];
                const startX = 0;
                const startY = 0;
                
                // Check bounds
                if (startY >= maze.length || startX >= maze[0].length) {
                    throw new Error("Start position out of bounds");
                }
                
                // Mark the starting cell as visited
                maze[startY][startX].visited = true;
                stack.push({ x: startX, y: startY });
                
                // Continue until all cells are visited
                while (stack.length > 0) {
                    // Get the current cell
                    const current = stack[stack.length - 1];
                    const { x, y } = current;
                    
                    // Get unvisited neighbors
                    const neighbors = getUnvisitedNeighbors(x, y);
                    
                    if (neighbors.length === 0) {
                        // No unvisited neighbors, backtrack
                        stack.pop();
                    } else {
                        // Choose a random unvisited neighbor
                        const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                        
                        // Remove walls between current cell and chosen neighbor
                        if (next.x > x) {
                            // Remove right wall of current and left wall of neighbor
                            maze[y][x].walls.right = false;
                            maze[next.y][next.x].walls.left = false;
                        } else if (next.x < x) {
                            // Remove left wall of current and right wall of neighbor
                            maze[y][x].walls.left = false;
                            maze[next.y][next.x].walls.right = false;
                        } else if (next.y > y) {
                            // Remove bottom wall of current and top wall of neighbor
                            maze[y][x].walls.bottom = false;
                            maze[next.y][next.x].walls.top = false;
                        } else if (next.y < y) {
                            // Remove top wall of current and bottom wall of neighbor
                            maze[y][x].walls.top = false;
                            maze[next.y][next.x].walls.bottom = false;
                        }
                        
                        // Mark the neighbor as visited and push to stack
                        maze[next.y][next.x].visited = true;
                        stack.push(next);
                    }
                }
                
                console.log("Maze paths generated, creating visual elements");
                
                // Create the maze walls
                createMazeWalls(cols, rows);
                
                // Create path lines and nodes for navigation
                createPathLines(cols, rows);
                
                // Add player
                createPlayer(startX, startY);
                
                // Add goal at the opposite corner (bottom-right)
                createGoal(cols - 1, rows - 1);
                
                // Set up player movement
                setupPlayerMovement();
                
                console.log("Maze generation complete");
                
            } catch (error) {
                console.error("Error during maze generation:", error);
                showError("Maze creation failed: " + error.message);
                throw error; // Re-throw to stop execution
            }
        }
        
        // Create the player element
        function createPlayer(x, y) {
            player = document.createElement('div');
            player.id = 'player';
            
            // Position at the center of the starting cell
            const posX = x * cellSize + cellSize / 2;
            const posY = y * cellSize + cellSize / 2;
            
            player.style.left = `${posX}px`;
            player.style.top = `${posY}px`;
            
            mazeContainer.appendChild(player);
        }
        
        // Create the goal element
        function createGoal(x, y) {
            goal = document.createElement('div');
            goal.id = 'goal';
            
            // Position at the center of the goal cell
            const posX = x * cellSize + cellSize / 2;
            const posY = y * cellSize + cellSize / 2;
            
            goal.style.left = `${posX}px`;
            goal.style.top = `${posY}px`;
            goal.style.width = `${cellSize * 0.7}px`;
            goal.style.height = `${cellSize * 0.7}px`;
            
            mazeContainer.appendChild(goal);
        }
        
        // Setup player movement with keyboard and drag controls
        function setupPlayerMovement() {
            if (!player || pathNodes.length === 0) {
                console.error("Player or pathNodes not initialized");
                return;
            }
            
            // Reference to player position
            let playerX = parseFloat(player.style.left);
            let playerY = parseFloat(player.style.top);
            let startX, startY;
            let closestNodeIndex = 0;
            
            // Find the closest node index for starting position
            try {
                updateClosestNodeIndex();
            } catch (error) {
                console.error("Error finding closest node:", error);
                return;
            }
            
            // Define all event handlers using named functions so they can be removed later
            function handleKeyDown(e) {
                if (!isSessionActive) return;
                
                const currentNode = pathNodes[closestNodeIndex];
                let nextNodeIndex = -1;
                
                // Check which connected node to move to based on key press
                switch (e.key) {
                    case 'ArrowUp':
                        // Find node above current node
                        nextNodeIndex = currentNode.connections.find(index => 
                            pathNodes[index].y < currentNode.y && 
                            pathNodes[index].x === currentNode.x
                        );
                        break;
                    case 'ArrowDown':
                        // Find node below current node
                        nextNodeIndex = currentNode.connections.find(index => 
                            pathNodes[index].y > currentNode.y && 
                            pathNodes[index].x === currentNode.x
                        );
                        break;
                    case 'ArrowLeft':
                        // Find node to the left of current node
                        nextNodeIndex = currentNode.connections.find(index => 
                            pathNodes[index].x < currentNode.x && 
                            pathNodes[index].y === currentNode.y
                        );
                        break;
                    case 'ArrowRight':
                        // Find node to the right of current node
                        nextNodeIndex = currentNode.connections.find(index => 
                            pathNodes[index].x > currentNode.x && 
                            pathNodes[index].y === currentNode.y
                        );
                        break;
                    default:
                        return;
                }
                
                // If valid connection found, move to the next node
                if (nextNodeIndex !== undefined && nextNodeIndex !== -1) {
                    moveToNode(nextNodeIndex);
                    e.preventDefault(); // Prevent scrolling
                }
            }
            
            function startDrag(e) {
                if (!isSessionActive) return;
                
                isDragging = true;
                
                // Get container's position relative to viewport
                const rect = mazeContainer.getBoundingClientRect();
                
                // Capture start position relative to the maze container
                if (e.type === 'mousedown') {
                    startX = e.clientX - rect.left;
                    startY = e.clientY - rect.top;
                } else if (e.type === 'touchstart') {
                    startX = e.touches[0].clientX - rect.left;
                    startY = e.touches[0].clientY - rect.top;
                    e.preventDefault(); // Prevent scrolling on touch
                }
                
                // Add active class for visual feedback
                player.style.boxShadow = '0 0 20px rgba(111, 211, 245, 0.9)';
            }
            
            function drag(e) {
                if (!isDragging || !isSessionActive) return;
                
                // Get container's position relative to viewport
                const rect = mazeContainer.getBoundingClientRect();
                
                let currentX, currentY;
                
                // Get current position relative to the maze container
                if (e.type === 'mousemove') {
                    currentX = e.clientX - rect.left;
                    currentY = e.clientY - rect.top;
                } else if (e.type === 'touchmove') {
                    currentX = e.touches[0].clientX - rect.left;
                    currentY = e.touches[0].clientY - rect.top;
                    e.preventDefault(); // Prevent scrolling on touch
                }
                
                // Calculate drag direction and distance
                const deltaX = currentX - startX;
                const deltaY = currentY - startY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // Scale the drag threshold relative to cell size (25% of cell size)
                const dragThreshold = cellSize * 0.25;
                
                // Only process if dragged far enough to avoid accidental movements
                if (distance > dragThreshold) {
                    const currentNode = pathNodes[closestNodeIndex];
                    let nextNodeIndex = -1;
                    
                    // Determine primary direction of drag
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        // Horizontal drag
                        if (deltaX > 0) {
                            // Find node to the right
                            nextNodeIndex = currentNode.connections.find(index => 
                                pathNodes[index].x > currentNode.x && 
                                pathNodes[index].y === currentNode.y
                            );
                        } else {
                            // Find node to the left
                            nextNodeIndex = currentNode.connections.find(index => 
                                pathNodes[index].x < currentNode.x && 
                                pathNodes[index].y === currentNode.y
                            );
                        }
                    } else {
                        // Vertical drag
                        if (deltaY > 0) {
                            // Find node below
                            nextNodeIndex = currentNode.connections.find(index => 
                                pathNodes[index].y > currentNode.y && 
                                pathNodes[index].x === currentNode.x
                            );
                        } else {
                            // Find node above
                            nextNodeIndex = currentNode.connections.find(index => 
                                pathNodes[index].y < currentNode.y && 
                                pathNodes[index].x === currentNode.x
                            );
                        }
                    }
                    
                    // If valid connection found, move to the next node
                    if (nextNodeIndex !== undefined && nextNodeIndex !== -1) {
                        moveToNode(nextNodeIndex);
                        
                        // Update start position to the ship's new center instead of the pointer position
                        // This ensures each drag must cross the threshold from the ship's center
                        startX = pathNodes[nextNodeIndex].x;
                        startY = pathNodes[nextNodeIndex].y;
                    }
                }
            }
            
            function endDrag() {
                isDragging = false;
                player.style.boxShadow = '0 0 15px rgba(111, 211, 245, 0.6)';
            }
            
            // Store references to event handlers
            eventHandlers.keydown = handleKeyDown;
            eventHandlers.mousedown = startDrag;
            eventHandlers.touchstart = startDrag;
            eventHandlers.mousemove = drag;
            eventHandlers.touchmove = drag;
            eventHandlers.mouseup = endDrag;
            eventHandlers.touchend = endDrag;
            
            // Attach the event listeners
            mazeContainer.addEventListener('keydown', eventHandlers.keydown);
            player.addEventListener('mousedown', eventHandlers.mousedown);
            player.addEventListener('touchstart', eventHandlers.touchstart, { passive: false });
            document.addEventListener('mousemove', eventHandlers.mousemove);
            document.addEventListener('touchmove', eventHandlers.touchmove, { passive: false });
            document.addEventListener('mouseup', eventHandlers.mouseup);
            document.addEventListener('touchend', eventHandlers.touchend);
            
            function moveToNode(nodeIndex) {
                if (nodeIndex >= 0 && nodeIndex < pathNodes.length) {
                    const targetNode = pathNodes[nodeIndex];
                    
                    // Add path trace if enabled
                    if (showTrace) {
                        addPathTrace(playerX, playerY, targetNode.x, targetNode.y);
                    }
                    
                    // Update player position
                    playerX = targetNode.x;
                    playerY = targetNode.y;
                    player.style.left = `${playerX}px`;
                    player.style.top = `${playerY}px`;
                    closestNodeIndex = nodeIndex;
                    
                    // Check if player reached the goal
                    checkGoalReached();
                }
            }
            
            function updateClosestNodeIndex() {
                // Find the closest node to the player
                if (pathNodes.length === 0) {
                    console.error("No path nodes available");
                    return;
                }
                
                let minDistance = Infinity;
                
                for (let i = 0; i < pathNodes.length; i++) {
                    const node = pathNodes[i];
                    const dx = node.x - playerX;
                    const dy = node.y - playerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestNodeIndex = i;
                    }
                }
            }
            
            function addPathTrace(fromX, fromY, toX, toY) {
                const trace = document.createElement('div');
                trace.className = 'path-trace';
                
                // Calculate center point and dimensions
                const centerX = (fromX + toX) / 2;
                const centerY = (fromY + toY) / 2;
                const width = Math.abs(toX - fromX) + 10; // Add a bit of padding
                const height = Math.abs(toY - fromY) + 10;
                
                // Position trace
                trace.style.left = `${centerX - width / 2}px`;
                trace.style.top = `${centerY - height / 2}px`;
                trace.style.width = `${width}px`;
                trace.style.height = `${height}px`;
                
                // Add to container and track
                mazeContainer.appendChild(trace);
                pathTraces.push(trace);
            }
            
            function checkGoalReached() {
                // Get goal position
                const goalX = parseFloat(goal.style.left);
                const goalY = parseFloat(goal.style.top);
                
                // Calculate distance between player and goal
                const dx = playerX - goalX;
                const dy = playerY - goalY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // If player is close enough to goal, consider it reached
                const goalRadius = parseFloat(goal.style.width) / 2;
                if (distance < goalRadius) {
                    completeCurrentMaze();
                }
            }
        }
    </script>
</body>
</html>