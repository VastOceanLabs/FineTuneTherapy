<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Cosmic Maze Exercise ‚Äî Fine Tune Therapy</title>
  <meta name="description" content="Evidence‚Äëbased fine‚Äëmotor exercise: guide your spaceship through a procedurally‚Äëgenerated cosmic maze. Designed for adults with dexterity impairments.">
  <style>
    /* ‚Äî‚Äî Colour & font tokens ‚Äî‚Äî */
    :root {
      --clr-bg: #121d33;
      --clr-accent: #6fd3f5;
      --clr-accent-strong: rgba(111,211,245,0.9);
      --clr-accent-soft: rgba(111,211,245,0.3);
      --clr-surface: rgba(8,15,35,0.95);
      --clr-text: #ffffff;
      --radius-lg: 15px;
      --shadow-elev: 0 10px 30px rgba(0,0,0,0.5);
    }
    /* ‚Äî‚Äî Basic reset ‚Äî‚Äî */
    *,*::before,*::after{box-sizing:border-box;}body{margin:0;padding:0;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;background:var(--clr-bg);color:var(--clr-text);min-height:100vh;-webkit-user-select:none;user-select:none;touch-action:manipulation;overflow:hidden;}
    /* ‚Äî‚Äî Game layout ‚Äî‚Äî */
    #game-container{position:relative;width:100vw;height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;overflow:hidden;}
    #maze-container{position:relative;border:2px solid var(--clr-accent-soft);border-radius:8px;box-shadow:0 0 20px var(--clr-accent-soft);background:rgba(0,0,0,0.3);touch-action:none;}
    .maze-wall{position:absolute;background:linear-gradient(135deg,rgba(7,25,59,.9),rgba(11,42,88,.9));border:1px solid var(--clr-accent-soft);box-shadow:0 0 8px var(--clr-accent-soft);}
    /* Player & goal share accessible minimum size (‚â• 56 px) */
    #player,#goal{position:absolute;transform:translate(-50%,-50%);border-radius:50%;touch-action:none;}
    #player{background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23ffffff'%3E%3Cpath d='M12,1L2,8.5V20.5H22V8.5L12,1M12,3.5L19,9V10.5H5V9L12,3.5M5,20.5V12H19V20.5H5M8.5,12.5A2.5,2.5 0 0,0 6,15A2.5,2.5 0 0,0 8.5,17.5A2.5,2.5 0 0,0 11,15A2.5,2.5 0 0,0 8.5,12.5M15.5,12.5A2.5,2.5 0 0,0 13,15A2.5,2.5 0 0,0 15.5,17.5A2.5,2.5 0 0,0 18,15A2.5,2.5 0 0,0 15.5,12.5M12,12V20H7V15H17V20H12V12Z'/%3E%3C/svg%3E");background-size:contain;background-repeat:no-repeat;background-color:rgba(111,211,245,.15);box-shadow:0 0 15px rgba(111,211,245,.6);animation:pulse 1.5s infinite alternate;}
    @keyframes pulse{0%{box-shadow:0 0 15px rgba(111,211,245,.6);}100%{box-shadow:0 0 25px rgba(111,211,245,.8);}}
    #goal{background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%234CAF50'%3E%3Cpath d='M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4M12,6.5A5.5,5.5 0 0,0 6.5,12A5.5,5.5 0 0,0 12,17.5A5.5,5.5 0 0,0 17.5,12A5.5,5.5 0 0,0 12,6.5M12,9A3,3 0 0,1 15,12A3,3 0 0,1 12,15A3,3 0 0,1 9,12A3,3 0 0,1 12,9Z'/%3E%3C/svg%3E");background-size:contain;background-repeat:no-repeat;box-shadow:0 0 20px rgba(76,175,80,.8);animation:earthPulse 2s infinite alternate;}@keyframes earthPulse{0%{box-shadow:0 0 20px rgba(76,175,80,.7);}100%{box-shadow:0 0 30px rgba(76,175,80,.9);}}
    /* Path trace */
    .path-trace{position:absolute;background-color:var(--clr-accent-soft);border-radius:50%;pointer-events:none;transition:opacity 0.5s;}
    .path-trace.pooled{opacity:0;visibility:hidden;}
    /* Timer bar */
    #timer-bar{position:absolute;top:0;left:0;height:8px;background-color:var(--clr-accent-strong);width:100%;z-index:20;transition:width 0.1s linear;}
    /* Pause overlay */
    #pause-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;z-index:1000;}
    #pause-message{background:var(--clr-surface);padding:30px;border-radius:var(--radius-lg);text-align:center;}
    #pause-message h2{margin:0 0 20px;}
    /* Settings panel & button */
    #settings-toggle{position:fixed;bottom:15px;right:15px;width:56px;height:56px;border-radius:50%;border:none;background:var(--clr-accent);color:var(--clr-bg);font-size:14px;font-weight:700;display:flex;align-items:center;justify-content:center;box-shadow:0 4px 10px rgba(0,0,0,.3);cursor:pointer;transition:transform .2s;}#settings-toggle:hover{transform:translateY(-2px);}
    #settings-panel{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:var(--clr-surface);padding:25px;border-radius:var(--radius-lg);box-shadow:var(--shadow-elev);width:90%;max-width:400px;z-index:100;border:1px solid rgba(255,255,255,.1);}
    #settings-panel h2{margin:0 0 20px;text-align:center;letter-spacing:.5px;}
    .settings-group{margin-bottom:18px;}label.settings-label{display:block;margin-bottom:8px;font-weight:600;}
    select,input{width:100%;padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,.2);background:rgba(0,10,30,.8);color:#fff;font-size:16px;}select:focus,input:focus{outline:none;border-color:var(--clr-accent-strong);box-shadow:0 0 0 2px var(--clr-accent-soft);}
    button.primary{background:var(--clr-accent-strong);color:var(--clr-bg);border:none;border-radius:10px;padding:12px 0;font-size:16px;font-weight:700;cursor:pointer;width:100%;box-shadow:0 4px 6px rgba(0,0,0,.2);margin-bottom:10px;}button.primary:hover{transform:translateY(-2px);}
    button.secondary{background:transparent;color:var(--clr-text);border:1px solid var(--clr-accent-soft);border-radius:10px;padding:12px 0;font-size:16px;cursor:pointer;width:100%;}button.secondary:hover{background:var(--clr-accent-soft);}
    /* Stats footer */
    #stats-panel{position:absolute;left:0;right:0;bottom:0;background:rgba(8,15,35,.8);display:flex;justify-content:space-around;padding:14px;box-shadow:0 -2px 10px rgba(0,0,0,.3);}#stats-panel.hidden{display:none;}
    .stat-box{text-align:center;}.stat-value{font-size:24px;font-weight:700;color:var(--clr-accent);} .stat-label{font-size:14px;color:rgba(255,255,255,.8);} @media(max-width:768px){.stat-value{font-size:20px;}.stat-label{font-size:12px;}}
    /* History panel */
    #history-panel{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:var(--clr-surface);padding:25px;border-radius:var(--radius-lg);box-shadow:var(--shadow-elev);width:90%;max-width:500px;max-height:80vh;overflow-y:auto;z-index:100;border:1px solid rgba(255,255,255,.1);}
    .history-entry{padding:10px;border-bottom:1px solid rgba(255,255,255,.1);display:flex;justify-content:space-between;align-items:center;}
    .history-date{font-size:14px;color:rgba(255,255,255,.7);}
    .history-stats{text-align:right;}
    /* Difficulty suggestion */
    .difficulty-suggestion{background:rgba(76,175,80,.2);border:1px solid rgba(76,175,80,.5);border-radius:8px;padding:15px;margin:15px 0;text-align:center;}
    /* Control buttons */
    #control-buttons{position:fixed;top:15px;right:15px;display:flex;gap:10px;z-index:50;}
    #control-buttons button{width:48px;height:48px;border-radius:50%;border:none;background:var(--clr-accent-soft);color:var(--clr-text);font-size:18px;cursor:pointer;box-shadow:0 2px 8px rgba(0,0,0,.3);}
    #control-buttons button:hover{background:var(--clr-accent);}
    /* Misc */
    .instructions{max-width:600px;margin:0 0 15px;text-align:center;font-size:16px;background:rgba(8,15,35,.7);padding:15px;border-radius:8px;} .hidden{display:none!important;}
  </style>
</head>
<body>
  <div id="game-container" aria-label="Cosmic maze fine‚Äëmotor exercise" role="application">
    <div id="stars-container" aria-hidden="true"></div>
    <div id="timer-bar" class="hidden"></div>
    <p class="instructions">Guide the spaceship through the cosmic maze to reach Earth. Drag slowly or tap your destination ‚Äî slow gestures are accepted.</p>
    <div id="maze-container" aria-live="polite"></div>

    <!-- Control Buttons -->
    <div id="control-buttons" class="hidden">
      <button id="pause-btn" aria-label="Pause session">‚è∏Ô∏è</button>
      <button id="history-btn" aria-label="View history">üìä</button>
    </div>

    <!-- Settings Floating Action Button -->
    <button id="settings-toggle" aria-label="Open settings">‚öôÔ∏è</button>

    <!-- Settings Panel -->
    <section id="settings-panel" role="dialog" aria-modal="true" class="hidden">
      <h2>Maze Settings</h2>
      <div class="settings-group">
        <label class="settings-label" for="difficulty">Difficulty Level</label>
        <select id="difficulty" aria-label="Difficulty">
          <option value="easy" selected>Easy (Wide paths)</option>
          <option value="medium">Medium</option>
          <option value="hard">Hard (Narrow paths)</option>
        </select>
      </div>
      <div class="settings-group">
        <label class="settings-label" for="session-duration">Session Duration (minutes)</label>
        <input type="number" id="session-duration" value="5" min="1" max="10" aria-label="Session duration in minutes">
      </div>
      <div class="settings-group">
        <label class="settings-label" for="show-trace">Show Path Trace</label>
        <select id="show-trace" aria-label="Show trace">
          <option value="yes" selected>Yes</option>
          <option value="no">No</option>
        </select>
      </div>
      <button id="start-session" class="primary">Start Session</button>
      <button id="view-history" class="secondary">View History</button>
    </section>

    <!-- History Panel -->
    <section id="history-panel" role="dialog" aria-modal="true" class="hidden">
      <h2>Exercise History</h2>
      <div id="history-content"></div>
      <button id="close-history" class="primary">Close</button>
      <button id="export-history" class="secondary">Export Data</button>
    </section>

    <!-- Pause Overlay -->
    <div id="pause-overlay" class="hidden">
      <div id="pause-message">
        <h2>Session Paused</h2>
        <p>Take a break. Your progress has been saved.</p>
        <button id="resume-btn" class="primary">Resume</button>
        <button id="end-session-btn" class="secondary">End Session</button>
      </div>
    </div>

    <!-- Stats Footer -->
    <footer id="stats-panel" class="hidden" aria-live="polite">
      <div class="stat-box"><div id="mazes-completed" class="stat-value">0</div><div class="stat-label">Completed</div></div>
      <div class="stat-box"><div id="current-maze" class="stat-value">1</div><div class="stat-label">Current Maze</div></div>
      <div class="stat-box"><div id="time-left" class="stat-value">5:00</div><div class="stat-label">Time Left</div></div>
      <div class="stat-box"><div id="avg-time" class="stat-value">0.0s</div><div class="stat-label">Avg. Time</div></div>
    </footer>

    <!-- Completion Dialog -->
    <section id="completion-message" class="hidden" role="dialog" aria-modal="true">
      <h2>Session Complete!</h2>
      <div id="completion-scores">
        <p>Mazes Completed: <span id="final-completed" class="stat-value">0</span></p>
        <p>Avg. Completion Time: <span id="final-avg-time" class="stat-value">0.0s</span></p>
        <p>Score: <span id="final-score" class="stat-value">0</span></p>
      </div>
      <div id="difficulty-suggestion" class="difficulty-suggestion hidden">
        <p>Great job! Consider trying a harder difficulty next time.</p>
      </div>
      <button id="restart-button" class="primary">Start New Session</button>
    </section>
  </div>

  <script>
  (()=>{
    "use strict";
    
    /* ‚Äî‚Äî Safe storage helpers ‚Äî‚Äî */
    const safeStorage = {
      get(key) {
        try {
          return localStorage.getItem(key);
        } catch(e) {
          console.warn('Storage access failed:', e);
          return null;
        }
      },
      set(key, val) {
        try {
          localStorage.setItem(key, val);
        } catch(e) {
          console.warn('Storage write failed:', e);
        }
      },
      getJSON(key, defaultValue = null) {
        try {
          const item = localStorage.getItem(key);
          return item ? JSON.parse(item) : defaultValue;
        } catch(e) {
          console.warn('JSON parse failed:', e);
          return defaultValue;
        }
      },
      setJSON(key, val) {
        try {
          localStorage.setItem(key, JSON.stringify(val));
        } catch(e) {
          console.warn('JSON stringify failed:', e);
        }
      }
    };

    /* ‚Äî‚Äî Constants ‚Äî‚Äî */
    const MIN_TARGET_PX = 56; // ‚âà14 mm on 4√ó devices
    const difficultySettings = {
      easy: { cell: 60, wall: 12, successThreshold: 0.8 },
      medium: { cell: 45, wall: 10, successThreshold: 0.85 },
      hard: { cell: 30, wall: 8, successThreshold: 0.9 }
    };

    /* ‚Äî‚Äî Collision Grid Class ‚Äî‚Äî */
    class CollisionGrid {
      constructor(gridSize = 20) {
        this.gridSize = gridSize;
        this.grid = new Map();
        this.walls = [];
      }

      clear() {
        this.grid.clear();
        this.walls = [];
      }

      addWall(wall) {
        this.walls.push(wall);
        const bounds = wall.getBounds();
        const minX = Math.floor(bounds.x / this.gridSize);
        const minY = Math.floor(bounds.y / this.gridSize);
        const maxX = Math.floor((bounds.x + bounds.width) / this.gridSize);
        const maxY = Math.floor((bounds.y + bounds.height) / this.gridSize);

        for (let x = minX; x <= maxX; x++) {
          for (let y = minY; y <= maxY; y++) {
            const key = `${x},${y}`;
            if (!this.grid.has(key)) {
              this.grid.set(key, []);
            }
            this.grid.get(key).push(wall);
          }
        }
      }

      getWallsInArea(x, y, radius) {
        const walls = new Set();
        const minX = Math.floor((x - radius) / this.gridSize);
        const minY = Math.floor((y - radius) / this.gridSize);
        const maxX = Math.floor((x + radius) / this.gridSize);
        const maxY = Math.floor((y + radius) / this.gridSize);

        for (let gx = minX; gx <= maxX; gx++) {
          for (let gy = minY; gy <= maxY; gy++) {
            const key = `${gx},${gy}`;
            if (this.grid.has(key)) {
              this.grid.get(key).forEach(wall => walls.add(wall));
            }
          }
        }
        return Array.from(walls);
      }
    }

    /* ‚Äî‚Äî DOM Pool for path traces ‚Äî‚Äî */
    class DOMPool {
      constructor(createElement, initialSize = 50) {
        this.createElement = createElement;
        this.pool = [];
        this.active = new Set();
        
        // Pre-create elements
        for (let i = 0; i < initialSize; i++) {
          this.pool.push(this.createElement());
        }
      }

      acquire() {
        let element;
        if (this.pool.length > 0) {
          element = this.pool.pop();
          element.classList.remove('pooled');
        } else {
          element = this.createElement();
        }
        this.active.add(element);
        return element;
      }

      release(element) {
        if (this.active.has(element)) {
          this.active.delete(element);
          element.classList.add('pooled');
          this.pool.push(element);
        }
      }

      releaseAll() {
        this.active.forEach(element => {
          element.classList.add('pooled');
          this.pool.push(element);
        });
        this.active.clear();
      }
    }

    /* ‚Äî‚Äî DOM refs ‚Äî‚Äî */
    const $ = id => document.getElementById(id);
    const gameContainer = $("game-container");
    const mazeContainer = $("maze-container");
    const timerBar = $("timer-bar");
    const settingsPanel = $("settings-panel");
    const settingsBtn = $("settings-toggle");
    const statsPanel = $("stats-panel");
    const instructions = document.querySelector(".instructions");
    const completionMsg = $("completion-message");
    const historyPanel = $("history-panel");
    const pauseOverlay = $("pause-overlay");
    const controlButtons = $("control-buttons");
    
    // Controls
    const difficultySel = $("difficulty");
    const durationInp = $("session-duration");
    const traceSel = $("show-trace");
    const startBtn = $("start-session");
    const restartBtn = $("restart-button");
    const viewHistoryBtn = $("view-history");
    const closeHistoryBtn = $("close-history");
    const exportHistoryBtn = $("export-history");
    const pauseBtn = $("pause-btn");
    const resumeBtn = $("resume-btn");
    const endSessionBtn = $("end-session-btn");
    const historyBtn = $("history-btn");
    
    // Stats elements
    const mazesCompletedEl = $("mazes-completed");
    const currentMazeEl = $("current-maze");
    const timeLeftEl = $("time-left");
    const avgTimeEl = $("avg-time");
    const finalCompletedEl = $("final-completed");
    const finalAvgTimeEl = $("final-avg-time");
    const finalScoreEl = $("final-score");
    const difficultyEl = $("difficulty-suggestion");

    /* ‚Äî‚Äî State ‚Äî‚Äî */
    let sessionActive = false;
    let sessionPaused = false;
    let timerMs = 0;
    let durationMs = 5 * 60e3;
    let timerHandle = null;
    let mazesCompleted = 0;
    let currentMaze = 1;
    let totalTime = 0;
    let mazeStart = 0;
    let showTrace = true;
    let difficulty = "easy";
    let maze = [];
    let cellSize = 60;
    let wallThick = 10;
    let mazeW = 600;
    let mazeH = 400;
    let player, goal;
    let sessionHistory = [];
    let collisionGrid = new CollisionGrid();
    let tracePool;

    /* ‚Äî‚Äî Init ‚Äî‚Äî */
    function init() {
      loadSessionHistory();
      applySavedSettings();
      resizeMaze();
      setupEventListeners();
      createStars();
      
      // Initialize trace pool
      tracePool = new DOMPool(() => {
        const dot = document.createElement("div");
        dot.className = "path-trace pooled";
        mazeContainer.appendChild(dot);
        return dot;
      });
    }

    /* ‚Äî‚Äî Event Listeners Setup ‚Äî‚Äî */
    function setupEventListeners() {
      window.addEventListener("resize", handleResize);
      settingsBtn.addEventListener("click", () => !sessionActive && settingsPanel.classList.toggle("hidden"));
      startBtn.addEventListener("click", startSession);
      restartBtn.addEventListener("click", showSettings);
      viewHistoryBtn.addEventListener("click", showHistory);
      closeHistoryBtn.addEventListener("click", () => historyPanel.classList.add("hidden"));
      exportHistoryBtn.addEventListener("click", exportHistory);
      pauseBtn.addEventListener("click", pauseSession);
      resumeBtn.addEventListener("click", resumeSession);
      endSessionBtn.addEventListener("click", endSession);
      historyBtn.addEventListener("click", showHistory);
      
      // Visibility change for auto-pause
      document.addEventListener("visibilitychange", () => {
        if (document.hidden && sessionActive && !sessionPaused) {
          pauseSession();
        }
      });
    }

    /* ‚Äî‚Äî Resize handler with debounce ‚Äî‚Äî */
    let resizeTimeout;
    function handleResize() {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        resizeMaze();
        if (sessionActive) {
          // Regenerate collision grid after resize
          setupCollisionGrid();
        }
      }, 250);
    }

    /* ‚Äî‚Äî Session History ‚Äî‚Äî */
    function loadSessionHistory() {
      sessionHistory = safeStorage.getJSON('sessionHistory', []);
    }

    function saveSessionHistory() {
      const historyEntry = {
        date: new Date().toISOString(),
        mazesCompleted,
        avgTime: mazesCompleted ? totalTime / mazesCompleted / 1000 : 0,
        difficulty,
        score: calculateScore()
      };
      
      sessionHistory.push(historyEntry);
      // Keep only last 50 sessions
      if (sessionHistory.length > 50) {
        sessionHistory = sessionHistory.slice(-50);
      }
      
      safeStorage.setJSON('sessionHistory', sessionHistory);
    }

    function showHistory() {
      const content = $("history-content");
      content.innerHTML = '';
      
      if (sessionHistory.length === 0) {
        content.innerHTML = '<p>No exercise history yet.</p>';
      } else {
        sessionHistory.slice().reverse().forEach(entry => {
          const div = document.createElement('div');
          div.className = 'history-entry';
          div.innerHTML = `
            <div class="history-date">${new Date(entry.date).toLocaleDateString()}</div>
            <div class="history-stats">
              <div>Mazes: ${entry.mazesCompleted}</div>
              <div>Avg: ${entry.avgTime.toFixed(1)}s</div>
              <div>Difficulty: ${entry.difficulty}</div>
              <div>Score: ${entry.score}</div>
            </div>
          `;
          content.appendChild(div);
        });
      }
      
      historyPanel.classList.remove("hidden");
    }

    function exportHistory() {
      const data = JSON.stringify(sessionHistory, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `maze-exercise-history-${new Date().toISOString().split('T')[0]}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    /* ‚Äî‚Äî Pause/Resume functionality ‚Äî‚Äî */
    function pauseSession() {
      if (!sessionActive || sessionPaused) return;
      
      sessionPaused = true;
      clearInterval(timerHandle);
      pauseOverlay.classList.remove("hidden");
      
      // Vibrate if available
      if ('vibrate' in navigator) {
        navigator.vibrate(100);
      }
    }

    function resumeSession() {
      if (!sessionActive || !sessionPaused) return;
      
      sessionPaused = false;
      pauseOverlay.classList.add("hidden");
      
      // Resume timer
      timerHandle = setInterval(updateTimerTick, 100);
    }

    /* ‚Äî‚Äî Settings and persistence ‚Äî‚Äî */
    function applySavedSettings() {
      const d = safeStorage.get("mazeDiff");
      const t = safeStorage.get("mazeDur");
      const tr = safeStorage.get("mazeTrace");
      
      if (d) difficultySel.value = d;
      if (t) durationInp.value = t;
      if (tr) traceSel.value = tr;
      
      [difficultySel, durationInp, traceSel].forEach(el => {
        el.addEventListener("change", () => {
          safeStorage.set("mazeDiff", difficultySel.value);
          safeStorage.set("mazeDur", durationInp.value);
          safeStorage.set("mazeTrace", traceSel.value);
        });
      });
    }

    /* ‚Äî‚Äî Session management ‚Äî‚Äî */
    function startSession() {
      difficulty = difficultySel.value;
      durationMs = parseInt(durationInp.value || 5) * 60e3;
      showTrace = traceSel.value === "yes";
      
      mazesCompleted = 0;
      currentMaze = 1;
      totalTime = 0;
      timerMs = durationMs;
      sessionPaused = false;
      
      updateStats();
      updateTimer();
      clearMaze();
      
      settingsPanel.classList.add("hidden");
      instructions.classList.remove("hidden");
      statsPanel.classList.remove("hidden");
      timerBar.classList.remove("hidden");
      controlButtons.classList.remove("hidden");
      
      sessionActive = true;
      timerHandle = setInterval(updateTimerTick, 100);
      
      generateMaze();
      mazeStart = performance.now();
    }

    function updateTimerTick() {
      if (sessionPaused) return;
      
      timerMs -= 100;
      const prog = timerMs / durationMs;
      timerBar.style.width = `${prog * 100}%`;
      updateTimer();
      
      if (timerMs <= 0) {
        endSession();
      }
    }

    function endSession() {
      clearInterval(timerHandle);
      sessionActive = false;
      
      const avg = (mazesCompleted ? totalTime / mazesCompleted / 1000 : 0).toFixed(1);
      const score = calculateScore();
      
      finalCompletedEl.textContent = mazesCompleted;
      finalAvgTimeEl.textContent = avg;
      finalScoreEl.textContent = score;

      // Save session history
      saveSessionHistory();
      
      // Check if we should suggest difficulty increase
      checkDifficultyProgression();
      
      clearMaze();
      statsPanel.classList.add("hidden");
      timerBar.classList.add("hidden");
      instructions.classList.add("hidden");
      controlButtons.classList.add("hidden");
      completionMsg.classList.remove("hidden");
    }

    function calculateScore() {
      const avg = mazesCompleted ? totalTime / mazesCompleted / 1000 : 0;
      return Math.round(mazesCompleted * 1000 / (avg || 1));
    }

    function checkDifficultyProgression() {
      const successRate = mazesCompleted / currentMaze;
      const currentSettings = difficultySettings[difficulty];
      
      if (successRate > currentSettings.successThreshold && difficulty !== 'hard') {
        difficultyEl.classList.remove("hidden");
      } else {
        difficultyEl.classList.add("hidden");
      }
    }

    function showSettings() {
      completionMsg.classList.add("hidden");
      settingsPanel.classList.remove("hidden");
    }

    /* ‚Äî‚Äî Maze generation ‚Äî‚Äî */
    function generateMaze() {
      clearMaze();
      
      const settings = difficultySettings[difficulty];
      cellSize = settings.cell;
      wallThick = settings.wall;
      
      const cols = Math.floor(mazeW / cellSize);
      const rows = Math.floor(mazeH / cellSize);
      
      // Initialize maze grid
      maze = Array(rows).fill().map((_, y) => 
        Array(cols).fill().map((_, x) => ({
          x, y,
          walls: { t: 1, r: 1, b: 1, l: 1 },
          visited: false
        }))
      );
      
      // Generate maze using DFS
      dfs(0, 0);
      
      // Draw walls and set up collision detection
      drawWalls(cols, rows);
      setupCollisionGrid();
      
      // Add player and goal
      addPlayerAndGoal();
    }

    function dfs(x, y) {
      maze[y][x].visited = true;
      const neighbours = shuffle(getNeighbours(x, y));
      
      for (const { nx, ny, dir } of neighbours) {
        if (!maze[ny][nx].visited) {
          // Remove walls between current and neighbor
          maze[y][x].walls[dir] = 0;
          maze[ny][nx].walls[oppositeDir(dir)] = 0;
          dfs(nx, ny);
        }
      }
    }

    function getNeighbours(x, y) {
      const neighbours = [];
      if (y > 0) neighbours.push({ nx: x, ny: y - 1, dir: "t" });
      if (x < maze[0].length - 1) neighbours.push({ nx: x + 1, ny: y, dir: "r" });
      if (y < maze.length - 1) neighbours.push({ nx: x, ny: y + 1, dir: "b" });
      if (x > 0) neighbours.push({ nx: x - 1, ny: y, dir: "l" });
      return neighbours;
    }

    function oppositeDir(dir) {
      return { t: "b", b: "t", l: "r", r: "l" }[dir];
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function drawWalls(cols, rows) {
      // Draw maze walls
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const cell = maze[y][x];
          const px = x * cellSize;
          const py = y * cellSize;
          
          if (cell.walls.t) {
            createWall(px - wallThick / 2, py - wallThick / 2, cellSize + wallThick, wallThick);
          }
          if (cell.walls.r) {
            createWall((x + 1) * cellSize - wallThick / 2, py - wallThick / 2, wallThick, cellSize + wallThick);
          }
          if (cell.walls.b) {
            createWall(px - wallThick / 2, (y + 1) * cellSize - wallThick / 2, cellSize + wallThick, wallThick);
          }
          if (cell.walls.l) {
            createWall(px - wallThick / 2, py - wallThick / 2, wallThick, cellSize + wallThick);
          }
        }
      }
      
      // Draw outer frame
      createWall(-wallThick, -wallThick, mazeW + wallThick * 2, wallThick);
      createWall(mazeW, -wallThick, wallThick, mazeH + wallThick * 2);
      createWall(-wallThick, mazeH, mazeW + wallThick * 2, wallThick);
      createWall(-wallThick, -wallThick, wallThick, mazeH + wallThick * 2);
    }

    function createWall(x, y, w, h) {
      const wall = document.createElement("div");
      wall.className = "maze-wall";
      wall.style.cssText = `left:${x}px;top:${y}px;width:${w}px;height:${h}px`;
      mazeContainer.appendChild(wall);
      
      // Create wall object for collision detection
      const wallObj = {
        element: wall,
        getBounds() {
          return { x, y, width: w, height: h };
        }
      };
      
      // Add to collision grid
      collisionGrid.addWall(wallObj);
    }

    function setupCollisionGrid() {
      collisionGrid.clear();
      const walls = mazeContainer.querySelectorAll(".maze-wall");
      walls.forEach(wall => {
        const bounds = {
          x: parseInt(wall.style.left),
          y: parseInt(wall.style.top),
          width: parseInt(wall.style.width),
          height: parseInt(wall.style.height)
        };
        
        collisionGrid.addWall({
          element: wall,
          getBounds() { return bounds; }
        });
      });
    }

    /* ‚Äî‚Äî Player and goal ‚Äî‚Äî */
    function addPlayerAndGoal() {
      const playerSize = Math.max(MIN_TARGET_PX, cellSize * 0.7);
      const goalSize = Math.max(MIN_TARGET_PX + 10, cellSize * 0.9);
      
      // Create player
      player = document.createElement("div");
      player.id = "player";
      player.setAttribute("aria-label", "Spaceship");
      player.style.cssText = `width:${playerSize}px;height:${playerSize}px;left:${cellSize/2}px;top:${cellSize/2}px`;
      
      // Create goal
      goal = document.createElement("div");
      goal.id = "goal";
      goal.setAttribute("aria-label", "Earth goal");
      goal.style.cssText = `width:${goalSize}px;height:${goalSize}px;left:${mazeW-cellSize/2}px;top:${mazeH-cellSize/2}px`;
      
      mazeContainer.appendChild(player);
      mazeContainer.appendChild(goal);
      
      initMovement();
    }

    /* ‚Äî‚Äî Movement system ‚Äî‚Äî */
    function initMovement() {
      let dragging = false;
      let startX = 0, startY = 0;
      let currentX = 0, currentY = 0;
      
      // Unified pointer events
      function onPointerDown(e) {
        if (!sessionActive || sessionPaused) return;
        
        e.preventDefault();
        dragging = true;
        
        const rect = player.getBoundingClientRect();
        const cx = e.clientX || e.touches[0].clientX;
        const cy = e.clientY || e.touches[0].clientY;
        
        startX = cx - (rect.left + rect.width / 2);
        startY = cy - (rect.top + rect.height / 2);
        
        currentX = parseInt(player.style.left);
        currentY = parseInt(player.style.top);
      }
      
      function onPointerMove(e) {
        if (!dragging || !sessionActive || sessionPaused) return;
        
        e.preventDefault();
        
        const mazeRect = mazeContainer.getBoundingClientRect();
        const cx = (e.clientX || e.touches[0].clientX) - mazeRect.left - startX;
        const cy = (e.clientY || e.touches[0].clientY) - mazeRect.top - startY;
        
        moveTo(cx, cy);
      }
      
      function onPointerUp() {
        dragging = false;
      }
      
      function onTap(e) {
        if (dragging || !sessionActive || sessionPaused) return;
        
        const rect = mazeContainer.getBoundingClientRect();
        const x = (e.clientX || e.changedTouches[0].clientX) - rect.left;
        const y = (e.clientY || e.changedTouches[0].clientY) - rect.top;
        
        moveTowards(x, y);
      }
      
      // Add event listeners
      player.addEventListener("mousedown", onPointerDown);
      player.addEventListener("touchstart", onPointerDown, { passive: false });
      
      document.addEventListener("mousemove", onPointerMove);
      document.addEventListener("touchmove", onPointerMove, { passive: false });
      
      document.addEventListener("mouseup", onPointerUp);
      document.addEventListener("touchend", onPointerUp);
      
      mazeContainer.addEventListener("click", onTap);
      mazeContainer.addEventListener("touchend", e => {
        if (!dragging) onTap(e);
      });
    }

    /* ‚Äî‚Äî Movement physics ‚Äî‚Äî */
    function moveTo(targetX, targetY) {
      // Clamp to maze boundaries
      targetX = Math.max(0, Math.min(targetX, mazeW));
      targetY = Math.max(0, Math.min(targetY, mazeH));
      
      // Check collision
      if (!checkCollision(targetX, targetY)) {
        player.style.left = `${targetX}px`;
        player.style.top = `${targetY}px`;
        
        if (showTrace) {
          leaveTrace(targetX, targetY);
        }
        
        checkGoal();
      }
    }

    function moveTowards(targetX, targetY) {
      // Simple movement towards target
      const currentX = parseInt(player.style.left);
      const currentY = parseInt(player.style.top);
      
      const steps = 20;
      const dx = (targetX - currentX) / steps;
      const dy = (targetY - currentY) / steps;
      
      let step = 0;
      const moveStep = () => {
        if (step >= steps) return;
        
        const newX = currentX + dx * step;
        const newY = currentY + dy * step;
        
        if (!checkCollision(newX, newY)) {
          player.style.left = `${newX}px`;
          player.style.top = `${newY}px`;
          
          if (showTrace) {
            leaveTrace(newX, newY);
          }
          
          step++;
          requestAnimationFrame(moveStep);
        }
      };
      
      moveStep();
    }

    function checkCollision(x, y) {
      const playerRadius = parseInt(player.style.width) / 2;
      const walls = collisionGrid.getWallsInArea(x, y, playerRadius);
      
      for (const wall of walls) {
        const bounds = wall.getBounds();
        
        if (x >= bounds.x - playerRadius &&
            x <= bounds.x + bounds.width + playerRadius &&
            y >= bounds.y - playerRadius &&
            y <= bounds.y + bounds.height + playerRadius) {
          return true;
        }
      }
      
      return false;
    }

    function leaveTrace(x, y) {
      const dot = tracePool.acquire();
      const size = Math.max(5, cellSize * 0.15);
      
      dot.style.cssText = `width:${size}px;height:${size}px;left:${x}px;top:${y}px;opacity:1;visibility:visible`;
      
      // Fade out after delay
      setTimeout(() => {
        dot.style.opacity = '0';
        setTimeout(() => {
          tracePool.release(dot);
        }, 500);
      }, 2000);
    }

    function checkGoal() {
      const playerRect = player.getBoundingClientRect();
      const goalRect = goal.getBoundingClientRect();
      
      const dx = (playerRect.left + playerRect.width / 2) - (goalRect.left + goalRect.width / 2);
      const dy = (playerRect.top + playerRect.height / 2) - (goalRect.top + goalRect.height / 2);
      
      if (Math.hypot(dx, dy) < (playerRect.width + goalRect.width) / 2 * 0.7) {
        // Goal reached!
        const completionTime = performance.now() - mazeStart;
        totalTime += completionTime;
        mazesCompleted++;
        currentMaze++;
        
        // Haptic feedback
        if ('vibrate' in navigator) {
          navigator.vibrate([100, 50, 100]);
        }
        
        updateStats();
        generateMaze();
        mazeStart = performance.now();
      }
    }

    /* ‚Äî‚Äî Utility functions ‚Äî‚Äî */
    function clearMaze() {
      mazeContainer.querySelectorAll(".maze-wall, #player, #goal").forEach(el => el.remove());
      if (tracePool) {
        tracePool.releaseAll();
      }
      collisionGrid.clear();
    }

    function updateStats() {
      mazesCompletedEl.textContent = mazesCompleted;
      currentMazeEl.textContent = currentMaze;
      avgTimeEl.textContent = `${mazesCompleted ? (totalTime / mazesCompleted / 1000).toFixed(1) : "0.0"}s`;
    }

    function updateTimer() {
      const minutes = Math.floor(timerMs / 60000);
      const seconds = Math.floor((timerMs % 60000) / 1000);
      timeLeftEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function resizeMaze() {
      mazeW = Math.min(600, window.innerWidth * 0.9);
      mazeH = Math.min(400, window.innerHeight * 0.6);
      mazeContainer.style.width = `${mazeW}px`;
      mazeContainer.style.height = `${mazeH}px`;
    }

    function createStars() {
      const starsContainer = $("stars-container");
      for (let i = 0; i < 150; i++) {
        const star = document.createElement("div");
        star.className = "star";
        star.style.cssText = `
          position: absolute;
          width: 2px;
          height: 2px;
          background: white;
          left: ${Math.random() * 100}%;
          top: ${Math.random() * 100}%;
          opacity: ${Math.random() * 0.8 + 0.2};
          animation: twinkle ${Math.random() * 5 + 5}s infinite;
        `;
        starsContainer.appendChild(star);
      }
      
      // Add twinkle animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes twinkle {
          0%, 100% { opacity: 0.2; }
          50% { opacity: 1; }
        }
      `;
      document.head.appendChild(style);
    }

    /* ‚Äî‚Äî Initialize on load ‚Äî‚Äî */
    document.addEventListener("DOMContentLoaded", init);
  })();
  </script>
</body>
</html>
